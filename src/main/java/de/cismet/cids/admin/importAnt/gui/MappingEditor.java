/*
 * MappingEditor.java
 *
 * Created on 11. November 2003, 11:33
 */

package de.cismet.cids.admin.importAnt.gui;
import de.cismet.cids.admin.importAnt.castorGenerated.*;
import java.util.Enumeration;
import java.io.*;
import javax.swing.table.*;
import de.cismet.common.gui.misc.*;
import java.util.*;
import javax.swing.*;
import java.awt.event.*;
import de.cismet.cids.tools.gui.farnsworth.*;

/**
 *
 * @author  hell
 */
public class MappingEditor extends javax.swing.JPanel {
    private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());

    private PreProcessingAndMapping mappings;
    /** Creates new form MappingEditor */
    public MappingEditor() {
        this(null);
    }
    public MappingEditor(PreProcessingAndMapping mappings) {
        initComponents();
        setContent(mappings);
        my_init();

    }
    
     public PreProcessingAndMapping getContent() {
        return this.getMappingModel().getMappings();
    }
    
    public void setContent(PreProcessingAndMapping mappings) {
        if (mappings==null) {
            mappings=new PreProcessingAndMapping();
        } 
        this.mappings=mappings;
//        TableSorter ts=new TableSorter(new MappingModel(mappings));
        tblMappings.setModel(new MappingModel(mappings));
//        ts.addMouseListenerToHeaderInTable(tblMappings);
    }    

    
    public void setSourceFieldNames(String[] fNames) {
        TableColumn tc=tblMappings.getColumnModel().getColumn(1);
        JComboBox combo=new JComboBox();
        combo.setBorder(new javax.swing.border.EmptyBorder(0,0,0,0));
        combo.setEditable(true);
        for (int i=0; i<fNames.length;++i) {
            combo.addItem(fNames[i]);
        }
        tc.setCellEditor(new DefaultCellEditor(combo));
    }
    
    public void addMappings(PreProcessingAndMapping maps) {
        Enumeration enum_=maps.enumerateMapping();
        while(enum_.hasMoreElements()) {
            Mapping m=(Mapping)enum_.nextElement();
            getMappingModel().addMapping(m);
        }
    }
    
    
    
    private MappingModel getMappingModel() {
        return ((MappingModel)(tblMappings.getModel()));
    }
    
    public void my_init() {
        
        tblMappings.setModel(new MappingModel(mappings));
        //ts.addMouseListenerToHeaderInTable(tblMappings);
        if (getMappingModel().getRowCount()==0) {
            getMappingModel().addRow();
            getMappingModel().fireTableDataChanged();
        }
//        for (int i=0;i<tblMappings.getColumnCount() ;++i) {
//            tblMappings.getColumnModel().getColumn(0).setCellRenderer(new ColoredCellRenderer());    
//        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        scpMappings = new javax.swing.JScrollPane();
        tblMappings = new javax.swing.JTable();
        cmdAddRow = new javax.swing.JButton();
        cmdDeleteRow = new javax.swing.JButton();

        setLayout(new java.awt.GridBagLayout());

        setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(10, 10, 10, 10)));
        scpMappings.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(0, 0, 0, 0)));
        tblMappings.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(0, 0, 0, 0)));
        tblMappings.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        scpMappings.setViewportView(tblMappings);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(scpMappings, gridBagConstraints);

        cmdAddRow.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/add_att.gif")));
        cmdAddRow.setBorderPainted(false);
        cmdAddRow.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/add_att.gif")));
        cmdAddRow.setDisabledSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/add_att.gif")));
        cmdAddRow.setFocusPainted(false);
        cmdAddRow.setMargin(new java.awt.Insets(2, 5, 1, 5));
        cmdAddRow.setPressedIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/add_att.gif")));
        cmdAddRow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdAddRowActionPerformed(evt);
            }
        });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
        add(cmdAddRow, gridBagConstraints);

        cmdDeleteRow.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/delete_edit.gif")));
        cmdDeleteRow.setBorderPainted(false);
        cmdDeleteRow.setDisabledIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/delete_edit.gif")));
        cmdDeleteRow.setDisabledSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/delete_edit.gif")));
        cmdDeleteRow.setFocusPainted(false);
        cmdDeleteRow.setMargin(new java.awt.Insets(2, 5, 1, 5));
        cmdDeleteRow.setPressedIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cids/admin/res/inactive2/delete_edit.gif")));
        cmdDeleteRow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdDeleteRowActionPerformed(evt);
            }
        });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
        gridBagConstraints.weighty = 1.0;
        add(cmdDeleteRow, gridBagConstraints);

    }//GEN-END:initComponents

    private void cmdDeleteRowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdDeleteRowActionPerformed
        int selRow=tblMappings.getSelectedRow();
        if (selRow!=-1) {
            getMappingModel().removeRow(selRow);
            if (getMappingModel().getRowCount()>0) {
                if (selRow==0) {
                    this.tblMappings.getSelectionModel().setSelectionInterval(0,0);
                } else {
                    this.tblMappings.getSelectionModel().setSelectionInterval(selRow-1,selRow-1);
                }
            }
        }
    }//GEN-LAST:event_cmdDeleteRowActionPerformed

    private void cmdAddRowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdAddRowActionPerformed
        getMappingModel().addRow();
    }//GEN-LAST:event_cmdAddRowActionPerformed
    
    public void markPotentialErrors(String[] s) {
        this.tblMappings.getCellRenderer(1,1).getTableCellRendererComponent(tblMappings, tblMappings.getValueAt(1,1), tblMappings.isCellSelected(1,1), false, 1, 1).setForeground(java.awt.Color.RED);
        tblMappings.revalidate();
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cmdAddRow;
    private javax.swing.JButton cmdDeleteRow;
    private javax.swing.JScrollPane scpMappings;
    private javax.swing.JTable tblMappings;
    // End of variables declaration//GEN-END:variables

    public static void main (String[] args) throws Exception{
        FileReader r=new FileReader("C:\\importTest.xml");
        // aus dem XML File die entsprechende Datenstruktur machen (CASTOR)
        ImportRules impRules=ImportRules.unmarshal(r);
        
        javax.swing.JFrame frame = new javax.swing.JFrame("SwingApplication");
        final MappingEditor t=new MappingEditor(impRules.getPreProcessingAndMapping());
        frame.getContentPane().add(t);

        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(t,evt);
            }
        });

        
        
        //Finish setting up the frame, and show it.
        frame.pack();
        frame.setVisible(true);
        
        
   }
    private static void exitForm(MappingEditor t,java.awt.event.WindowEvent evt) {
        PreProcessingAndMapping s=(PreProcessingAndMapping)(t.getContent());
        int i=s.getMappingCount();
        String ss=s.getMapping(19).getTargetField();
        System.exit(0);
    }
}

class MappingModel extends DefaultTableModel {
    final static String ENCLOSING_CHARACTER="'";
    PreProcessingAndMapping mappings;
    String[] cNames=new String[]{"Ziel","Quelle","Beziehungspfad","Z\u00E4hler","Vergleich","SD"};
    Vector maps=new Vector();
    public MappingModel(PreProcessingAndMapping mappings) {
        super();
        this.mappings=mappings;
        refresh();
    }
    
    public void setMappings(PreProcessingAndMapping mappings) {
        this.mappings=mappings;
        refresh();
    }
    
    public void refresh() {
        Enumeration enum_=mappings.enumerateMapping();
        maps.removeAllElements();
        while(enum_.hasMoreElements()) {
            Mapping m=(Mapping)enum_.nextElement();
            maps.add(m);
        }
        fireTableDataChanged();
    }
    
    public void addRow() {
        Mapping newMapping=new Mapping();
        mappings.addMapping(newMapping);
        maps.add(newMapping);
        this.fireTableDataChanged();
    }

    public void addMapping(Mapping m) {
        mappings.addMapping(m);
        maps.add(m);
        this.fireTableDataChanged();
    }
    
    public void removeRow(int row) {
        maps.removeElementAt(row);
        this.fireTableDataChanged();
    }
    
    
    
    public PreProcessingAndMapping getMappings()  {
        PreProcessingAndMapping ret=new PreProcessingAndMapping();
        for (int i=0; i< maps.size();++i) {
            ret.addMapping((Mapping)maps.elementAt(i));
        }
        return ret;
    }
    /** Liefert das allgemeinste Klassenobjekt, welches die Spalte beschreiben kann.*/
    public Class getColumnClass( int columnIndex ) {
        switch (columnIndex) {
            case 0:
                return java.lang.String.class;
            case 1:
                return java.lang.String.class;
            case 2:
                return java.lang.String.class;
            case 3:
                return java.lang.Boolean.class;
            case 4:
                return java.lang.Boolean.class;
            case 5 :
                return java.lang.Boolean.class;
        }
        return null;
    }
    
    /** Liefert die Anzahl Spalten.*/
    public int getColumnCount(){
        return 6;
    }
    
    /** Gibt den Namen der Spalte columnIndex zur\u00FCck. */
    public String getColumnName( int columnIndex ){
        return cNames[columnIndex];
    }
    
    /** Liefert die Anzahl der Zeilen.*/
    public int getRowCount(){
        if (maps==null) return 0;
        return maps.size();
    }

    /** Gibt den Eintrag an der Stelle columnIndex und rowIndex zur\u00FCck.*/
    public Object getValueAt( int rowIndex, int columnIndex ) {
        Mapping m=(Mapping)maps.get(rowIndex);
        switch (columnIndex) {
            case 0:
                String table="";
                String field="";
                if (m.getTargetTable()!=null) table=m.getTargetTable();
                if (m.getTargetField()!=null) field=m.getTargetField();
                if (!table.equals("")) table=table+".";
                return table.toUpperCase()+field;
            case 1:
                return m.getContent();
            case 2:
                String relNa=m.getPath();
                if (relNa==null) {
                    return "";
                }
                else {
                    return new String(relNa);
                }
            case 3:
                return new Boolean(m.getAutoIncrement());
            case 4:
                return new Boolean(m.getComparing());
            case 5:
                Boolean stringOrDate;
                if (m.getEnclosingChar()==null||m.getEnclosingChar().equals("")) {
                    stringOrDate=new Boolean(false);
                }
                else {
                    stringOrDate=new Boolean(true);
                }
                return stringOrDate;
        }
        return null;
    }
    
    /** Setzt den Wert an die gegebene Stelle.*/
    public void setValueAt( Object aValue, int rowIndex, int columnIndex ) {
        Mapping m=(Mapping)maps.get(rowIndex);
        try {
            switch (columnIndex) {
                case 0:
                    String tableAndField=((String)aValue);
                    String[] s=tableAndField.split("\\.");
                    if (s.length==2) {
                        m.setTargetTable(s[0].toUpperCase());
                        m.setTargetField(s[1]);
                    }
                    break;
                case 1:
                    String source=((String)aValue);
                    m.setContent(source);
                    break;
                case 2:
                    String relNa=((String)aValue);
                    m.setPath(relNa.toUpperCase());
                    break;
                case 3:
                    Boolean autoInc=((Boolean)aValue);
                    m.setAutoIncrement(autoInc.booleanValue());
                    break;
                case 4:
                    Boolean comp=((Boolean)aValue);
                    m.setComparing(comp.booleanValue());
                    break;
                case 5:
                    Boolean enclChar=((Boolean)aValue);
                    if (enclChar.booleanValue()) {
                        m.setEnclosingChar(ENCLOSING_CHARACTER);
                    }
                    else {
                        m.setEnclosingChar(null);
                    }
            }
        }
        catch (Exception e) {
                //keine Ver\u00E4nderung vornehmen;
        }
        maps.setElementAt(m, rowIndex);
        
        fireTableDataChanged();
    }
    
    /** Liefert true, wenn die Zelle an rowIndex und columnIndex editierbar ist.*/
    public boolean isCellEditable( int rowIndex, int columnIndex ) {
        return true;
    }
    
 

    
    
    
}
//
//class ColoredCellRenderer implements TableCellRenderer {
//    public ColoredCellRenderer() {
//    }
//    
//    public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
//        java.awt.Component c= new DefaultTableCellRenderer().getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
//        if (row==1&&column==1) {
//            c.setForeground(java.awt.Color.RED);
//        }
//        else {
//            c.setForeground(java.awt.Color.BLACK);
//        }
//        return c;
//    } 
//}


